<?xml version="1.0"?>
<rss version="2.0">
<channel>
<title>Devs on Acid</title>
<link>https://sabotage-linux.github.io</link>
<description>Random rants of a linux distribution developer</description>
<language>en</language>
<item><title>Restoring accidentally deleted files on Linux</title>
<guid>https://sabotage-linux.github.io/blog/6</guid>
<pubDate>02 May 2019 22:27 UTC</pubDate>
<description><![CDATA[
<p>Doh. Through a tiny bug in a Makefile auto-generated by my build system
<a href="https://github.com/rofl0r/rcb2">rcb2</a>, I accidentally deleted the C source file
I've been working on for almost an hour, and which wasn't checked into git yet.</p>

<p>Fortunately, I know the basic steps to restore a file<code>*</code> in a filesystem-agnostic
way.</p>

<p>These are:</p>

<ul>
<li>open the raw blockdevice (e.g. <code>/dev/sda1/</code>) the file was on,</li>
<li>search for a string known to be (only) inside the deleted file,</li>
<li>from that position on, find the start and end offsets of the file,</li>
<li>restore it using these offsets with the <code>dd</code> utility to another blockdevice.</li>
</ul>

<p>...</p>
]]></description></item>
<item><title>Mastering and designing C/C++ build systems</title>
<guid>https://sabotage-linux.github.io/blog/5</guid>
<pubDate>19 Apr 2019 10:36 UTC</pubDate>
<description><![CDATA[
<h2>A Primer for build system developers and users</h2>

<p>As the maintainer of
<a href="https://github.com/sabotage-linux/sabotage">sabotage linux</a>,
a distro compiled from source, with >1000
packages, and being involved in the development of
<a href="https://musl-libc.org/">musl libc</a>, I've seen a wide
variety of odd build systems, or regular build systems used in an odd way.
Which resulted in lots of issues trying to get other people's packages building.</p>

<p>The vast majority of build system coders and developers using these build systems
for their packages do not understand in detail how their toolchains are supposed
to be used,
and especially cross-compilation is a topic the majority of people knows nothing
...</p>
]]></description></item>
<item><title>benchmarking python bytecode vs interpreter speed and bazaar vs git</title>
<guid>https://sabotage-linux.github.io/blog/4</guid>
<pubDate>07 Apr 2019 00:39 UTC</pubDate>
<description><![CDATA[
<p>A couple weeks ago,
after an upgrade of libffi, we experienced odd build errors of python only on
systems where python had previously been installed with an older libffi version:</p>

<pre><code>error: [Errno 2] No such file or directory: '/lib/libffi-3.0.13/include/ffi.h'
</code></pre>

<p>There was no reference to <code>libffi-3.0.13</code> anywhere in the python source, and it
turned out that it was contained in old python .pyc/.pyo bytecode files that
survived a rebuild due to a packaging bug, and apparently were queried as
authorative during the python build.</p>

<pre><code>/lib/python2.7/_sysconfigdata.pyc:/lib/libffi-3.0.13/include
/lib/python2.7/_sysconfigdata.pyo:/lib/libffi-3.0.13/include
</code></pre>

<p>...</p>
]]></description></item>
<item><title>the rusty browser trap</title>
<guid>https://sabotage-linux.github.io/blog/3</guid>
<pubDate>06 Apr 2019 11:55 UTC</pubDate>
<description><![CDATA[
<p>If you're following <a href="https://github.com/sabotage-linux/sabotage/">sabotage linux</a>
development, you may have noticed that we're stuck on Firefox 52esr, which was
released over a year ago.
This is because non-optional parts of Firefox were rewritten in the "Rust"
programming language, and all newer versions now require to have a Rust compiler
installed.</p>

<h4>And that is a real problem.</h4>

<p>The Rust compiler is written in Rust itself, exposing the typical hen-and-egg
problem.
Its developers have used previous releases in binary form along the path of
evolution of the language and its compiler. This means in practice that one can
only build a rust compiler by using a binary build supplied by a third party,
...</p>
]]></description></item>
<item><title>how compatible is libreSSL ?</title>
<guid>https://sabotage-linux.github.io/blog/2</guid>
<pubDate>12 Jul 2014</pubDate>
<description><![CDATA[
<h4>portability</h4>

<p>yesterday the "portable" version of libressl was released.
http://ftp.openbsd.org/pub/OpenBSD/LibreSSL/libressl-2.0.0.tar.gz</p>

<p>i set up a package in <a href="https://github.com/sabotage-linux/sabotage">sabotage linux</a>,
and went on a voyage to investigate whether the full set of packages can be
used with libressl instead of openssl.</p>

<p>first of all, i had to fight some obstacles to get libressl compiling though...</p>

<h5>obstacle 1 - -Werror</h5>

<p>...</p>
]]></description></item>
<item><title>sqlite's anal gamation</title>
<guid>https://sabotage-linux.github.io/blog/1</guid>
<pubDate>25 Sep 2013</pubDate>
<description><![CDATA[
<p>sqlite's slogan: <strong>"Small. Fast. Reliable. Choose any three."</strong></p>

<p>i always wondered though, how such a small or "lite" package can take such a
considerable amount of time to build.</p>

<p>as the main author of the sabotage linux distribution, building software is my
daily bread, so i own a pretty fast build box.
it's an 8 core machine with 3.1 GHz, which builds a complete 3.11 linux kernel
in less than 5 minutes, making use of all 8 cores via the nice parallel build
feature of GNU make.</p>

<pre><code>make -j8
</code></pre>

<p>when invoking make like this, it first determines the dependencies between the
...</p>
]]></description></item>
</channel></rss>
