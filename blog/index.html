<html><head><title>Devs on Acid</title>
<link rel="alternate" href="/blog/feed.rss" type="application/rss+xml" title="Devs on Acid RSS">
<link rel="shortcut icon" href="/favicon.ico" type="image/png">
<link rel="stylesheet" href="/blog/main.css" type="text/css">
</head>

<body>

<div class="header">
<h1>Devs on Acid</h1>
<ul class="menu">
<li><a href="/blog/">Home</a>
<li><a href="/blog/about">About</a>
<li><a href="/blog/feed.rss">RSS</a>
</ul>
</div>

<div class="article"><h2><a href="2">how compatible is libreSSL ?</a></h2>

<div class="pub">12 Jul 2014</div>
<h4>portability</h4>

<p>yesterday the "portable" version of libressl was released.
http://ftp.openbsd.org/pub/OpenBSD/LibreSSL/libressl-2.0.0.tar.gz</p>

<p>i set up a package in <a href="https://github.com/sabotage-linux/sabotage">sabotage linux</a>,
and went on a voyage to investigate whether the full set of packages can be
used with libressl instead of openssl.</p>

<p>first of all, i had to fight some obstacles to get libressl compiling though...</p>

<h5>obstacle 1 - -Werror</h5>

<pre><code>../include/openssl/bio.h:622:3: error: '__bounded__' attribute directive ignored [-Werror=attributes]
</code></pre>

<p>-Werror is hardcoded in the configure script, which is a very bad idea, and the opposite of portable.
using -Werror is a guarantueed build break whenever the build is tried on a system the original developer had no access to.
it's sufficient to use a different compiler version, different libc version, etc to make new warnings pop up.</p>

<p>fixed with</p>

<pre><code>sed -i 's/-Werror//' configure
</code></pre>

<h5>obstacle 2 - unconditional inclusion of internal glibc header</h5>

<pre><code>compat/issetugid_linux.c:7:30: fatal error: gnu/libc-version.h: No such file or directory
</code></pre>

<p>many people assume linux == glibc, but that is not the reality.
sabotage linux uses <a href="http://www.musl-libc.org/">musl libc</a>, and there are at least 4 other libcs that could be used instead (uclibc, dietlibc, klibc, bionic).</p>

<p>looking at <a href="https://gist.github.com/rofl0r/7f2901ca1249e7b55d62">issetugid<em>linux.c</a> uncovers a dubious hack:
if glibc 2.19 is detected, getauxval(AT</em>SECURE) is not used, because there was once a bug (see comment in source code).</p>

<p>however it's common practice in distros to backport bugfixes, without updating the version number.
so this hack prevents proper usage of getauxval even if your libc version is long fixed.
the mentioned bug is very likely already fixed in any distro using glibc 2.19.</p>

<p>to get the thing out of my way and compilation going on, the quick fix was to cover everything with <code>#ifdef __GLIBC__</code>.
what the code really should do though is to just use the getauxval call unconditionally without the glibc version check.</p>

<h5>obstacle 3 - unnecessary unconditional inclusion of sys/sysctl.h</h5>

<pre><code>compat/getentropy_linux.c:27:24: fatal error: sys/sysctl.h: No such file or directory
</code></pre>

<p>musl does not have sys/sysctl.h, because:
(citing musl's author Rich Felker)</p>

<blockquote>
  <p>sysctl does not work, and NEVER worked. using it is bogus.
it was a bogus experimental syscall that was deprecated before it was ever used (basically, a broken binary version of /proc/sys, without any stability between kernel versions for what the binary constants meant).</p>
</blockquote>

<p>since the code in question does not use the sysctl function (declared in sys/sysctl.h) and does the syscall() directly,
it was safe and sufficient to just remove the include statement.</p>

<p>still it leaves a bad taste in my mouth that it was used at all...</p>

<p>having fixed these 3 issues, libressl built successfully.
<a href="https://github.com/sabotage-linux/sabotage/commit/4f2da253f669a0e2e69e6d5607e56c552b716eff">commit 4f2da253</a></p>

<p>on the plus side: using 8 cores, libressl builds in about 1 minute, while openssl requires 1:45.
also openssl depends on perl, which takes an additional 2 minutes buildtime.
so if nothing else depends on perl, it's about 3x faster.</p>

<h4>compatibility</h4>

<p>with libressl in place, a "world" metapackage (contains almost all packages) build was started.
the results:</p>

<p>wget failed to build due to lack of RAND_egd() function.
fixed by using a patch from openbsd.
<a href="https://github.com/sabotage-linux/sabotage/commit/234185c0dd408a9eeb6a14a31719760841f97be5">commit 234185c0</a></p>

<p>stunnel failed to build due to lack of RAND_egd() function.
fixed by using a custom patch conceptually equivalent to the wget one.
<a href="https://github.com/sabotage-linux/sabotage/commit/9b47cbbf3ce903dee042c45c8197db066e8e0053">commit 9b47cbb</a></p>

<p>cryptsetup and others failed to detect openssl due to lack of pkgconfig files.
i modified my package build script to create these .pc files (copies from openssl).
<a href="https://github.com/sabotage-linux/sabotage/commit/156a36253b9e19f83103135113451209796c39cf">commit 156a362</a></p>

<p>php, xorg-server and others failed to build subtly due to an ugly hack used in libressl's libcompat.a, linked into libcrypto.so:</p>

<pre><code>$ gcc test.c -lcrypto -fvisibility=hidden
/bin/ld: a.out: hidden symbol `main' in /tmp/ccobhDjc.o is referenced by DSO
/bin/ld: final link failed: Bad value

$ readelf -a /lib/libcrypto.so | grep main
000000345708 000a00000006 R_X86_64_GLOB_DAT 0000000000000000 main + 0
10: 0000000000000000 0 NOTYPE GLOBAL DEFAULT UND main
2146: 0000000000000000 0 NOTYPE GLOBAL DEFAULT UND main
</code></pre>

<p>in getentropy_linux.c:</p>

<pre><code>extern int main(int, char *argv[]);
#define HD(x) (SHA512_Update(&amp;ctx, (char *)&amp;(x), sizeof (x)))
HD(main); /* an addr in program */
</code></pre>

<p>the address of main() is used to gather entropy… very smart… NOT.</p>

<p>most of the methods used in this file to gather entropy are very dubious.
the crypto experts from OpenBSD should know better and just use /dev/urandom and/or getauxval(AT_RANDOM)
instead of all these hacks.</p>

<p><a href="https://github.com/sabotage-linux/sabotage/commit/1a8113699311c95a42c0cce5d09746ca290852ac">commit 1a81136</a></p>

<p>with that fixed, most programs expecting openssl seem to compile and work correctly.</p>

<p>mysql's CMAKE build system fails to detect SSL libraries.</p>

<pre><code>-- OPENSSL_INCLUDE_DIR = /usr/include
-- OPENSSL_LIBRARY = /usr/lib/libssl.so
-- CRYPTO_LIBRARY = /usr/lib/libcrypto.so
-- OPENSSL_MAJOR_VERSION = 2
-- Looking for SHA512_DIGEST_LENGTH
-- Looking for SHA512_DIGEST_LENGTH - found
CMake Error at cmake/ssl.cmake:231 (MESSAGE):
Cannot find appropriate system libraries for SSL. Use WITH_SSL=bundled to
enable SSL support
</code></pre>

<p>not patched yet.</p>

<p>the last build error was in apache:</p>

<pre><code>ssl_engine_init.c:445:28: error: `ENGINE_CTRL_CHIL_SET_FORKCHECK' undeclared
</code></pre>

<p>this is a macro which is available in openssl's engine.h, and was removed from libressl for unknown reasons.
not patched yet.</p>

<p>apart from these two, everything seems to be usable without big effort.
so if the libressl developers rip out all their dubious entropy generation methods in favor of /dev/urandom on linux it might be well worth switching to it.</p>

<p>the whole adventure is documented in the <a href="https://github.com/sabotage-linux/sabotage/commits/libressl_replaces_openssl">libressl<em>replaces</em>openssl branch</a>.</p>

<h4>Update 07/13</h4>

<p>OpenBSD released an updated version 2.0.1 earlier today.
the new release fixes the following problems
- reference to main() which breaks packages using -fvisibility=hidden
- usage of -Werror
- generation of pkg-config files
- unconditional inclusion of sys/sysctl.h</p>

<p>so the portability concerns have largely been addressed.
the only portability issue not fixed is the glibc-specific stuff in issetugid_linux.c.
instead, <a href="http://openwall.com/lists/musl/2014/07/12/28">a patch containing an issetugid implementation for inclusion in musl
was sent to the musl maillist</a>.</p>

<p>on the application compatibility side nothing seems to have changed.
RAND_egd() is still missing, as well as the macros used by apache.</p>

<p>the dubious fallbacks for getentropy (obsolete sysctl syscall, function addresses) are still present.</p>

<p><a href="https://blog.hboeck.de/archives/851-LibreSSL-on-Gentoo.html">this blog</a> about similar testing done on gentoo (recommended read) has a link to a patch for the apache build.
<a href="https://svn.hboeck.de/libressl-overlay/net-misc/openssh/files/openssh-arc4random.diff">there is also a patch for a segfault in openssh</a>.</p>

<h5>this blog post originally appeared on my currently defunct <a href="https://devsonacid.wordpress.com/2014/07/12/how-compatible-is-libressl/">wordpress blog</a></h5>
<p><a href="2/#comments">Post or read comments...</a></p></div>
<div class="article"><h2><a href="1">sqlite's anal gamation</a></h2>

<div class="pub">25 Sep 2013</div>
<p>sqlite's slogan: <strong>"Small. Fast. Reliable. Choose any three."</strong></p>

<p>i always wondered though, how such a small or "lite" package can take such a
considerable amount of time to build.</p>

<p>as the main author of the sabotage linux distribution, building software is my
daily bread, so i own a pretty fast build box.
it's an 8 core machine with 3.1 GHz, which builds a complete 3.11 linux kernel
in less than 5 minutes, making use of all 8 cores via the nice parallel build
feature of GNU make.</p>

<pre><code>make -j8
</code></pre>

<p>when invoking make like this, it first determines the dependencies between the
translation units,
and then runs up to 8 build processes, one per cpu core, each one building a
different .c file.</p>

<p>GCC 3.4.6, a C compiler with full C99 support builds in 43 sec:</p>

<pre><code>$ time butch rebuild gcc3
2013.09.25 12:13:50 building gcc3 (/src/build/build_gcc3.sh) -&gt; /src/logs/build_gcc3.log
2013.09.25 12:14:33 done.
real 0m 43.97s
user 1m 36.66s
sys 0m 13.74s
</code></pre>

<p>however, for sqlite, a supposedly small package, build times are comparatively huge:</p>

<pre><code>$ time butch rebuild sqlite
2013.09.25 12:18:27 building sqlite (/src/build/build_sqlite.sh) -&gt; /src/logs/build_sqlite.log
2013.09.25 12:19:21 done.
real 0m 54.03s
user 0m 52.02s
sys 0m 1.51s
</code></pre>

<p>nearly one minute, a fifth of the time used to build the linux kernel and 10
seconds more than the gcc compiler.</p>

<p>the full-blown postgresql database server package, takes <strong>less</strong> time to build
as well:</p>

<pre><code>$ time butch rebuild postgresql
2013.09.25 12:19:21 building postgresql (/src/build/build_postgresql.sh) -&gt; /src/logs/build_postgresql.log
2013.09.25 12:19:57 done.
real 0m 36.63s
user 1m 53.34s
sys 0m 12.03s
</code></pre>

<p>how is it possible that postgresql, shipping 16 MB of compressed sources, as
opposed to 1.8MB of sqlite, builds 33% faster ?</p>

<p>if you look at the user times above, you start getting an idea.
the user time (i.e. the entire cpu time burnt in userspace) for postgresql is
1m53, while the total time that actually passed was only 36s.</p>

<p>that means that the total work of 113 seconds was distributed among multiple
cpu cores.
dividing the user time through the real time gives us a concurrency factor of
3.13.
not perfect, given that make was invoked with -j8, but much better than sqlite,
 which apparently only used a single core.</p>

<p>let's take a look at sqlite's builddir</p>

<pre><code>$ find . -name '*.c'
./sqlite3.c
./shell.c
./tea/generic/tclsqlite3.c
./tea/win/nmakehlp.c
</code></pre>

<p>ah, funny. there are only 4 C files total. that partially explains why 8 cores
didn't help.
the 2 files in tea/ are not even used, which leaves us with</p>

<pre><code>$ ls -la *.c
-rw-r--r-- 1 root root 91925 Jan 16 2012 shell.c
-rw-r--r-- 1 root root 4711082 Jan 16 2012 sqlite3.c
</code></pre>

<p>so in the top level builddir, there are just 2 C files, one being 90 KB, and
the other roughly 5MB.
the 90KB version is built in less than 1 second, so after that the entire time
spent is waiting for the single cpu core building the huge sqlite3.c.</p>

<p>so why on earth would somebody stuff all source code into a single translation
unit and thereby defeat
makefile parallellism ?</p>

<p>after all, the IT industry's mantra of the last 10 years was
"parallellism, parallellism, and even more parallellism".</p>

<p>here's the explanation:
https://www.sqlite.org/amalgamation.html</p>

<p>it's a "feature", which they call amalgamation.</p>

<p>i call it anal gamation.</p>

<blockquote>
  <p>In addition to making SQLite easier to incorporate into other projects, the amalgamation also makes it run faster.
Many compilers are able to do additional optimizations on code when it is contained with in a single translation unit such as it is in the amalgamation. </p>
</blockquote>

<p>so they have 2 reasons for wasting our time:</p>

<ul>
<li>reason 1: easier to incorporate</li>
<li>reason 2: generated code is better as the compiler sees all code at once.</li>
</ul>

<p>let's look at <strong>reason 1</strong>:
what they mean with incorporation is embedding the sqlite source code into another projects source tree.</p>

<p>it is usually considered bad practice to embed third-party source code into your own source tree, for multiple reasons:</p>

<ul>
<li>every program that uses its own embedded copy of library X does not benefit from security updates when the default library install is updated.</li>
<li>we have multiple different versions on the harddrive and loaded in RAM, wasting system resources</li>
<li>having multiple incompatible versions can lead to a lot of breakage when it's used from another lib:
for example application X uses lib Y and lib Z, and lib Z uses a "incorporated" version of lib Y.
so we have a nice clash of 2 different lib Y versions. if lib Y has global state, it will get even worse.</li>
<li>if the library in question is using some unportable constructs, wrong ifdefs etc., it needs to be patched to build.
having to apply and maintain different sets of patches against multiple different versions "incorporated" into other packages, represents a big burden for the packager.</li>
</ul>

<p>instead, the installed version of libraries should be used.</p>

<p>pkg-config can be used to query existence, as well as CFLAGS and LDFLAGS needed
to build against the installed version of the library. if the required library
is not installed or too old, just throw an error at configure time and tell
the user to install it via apt-get or whatever.</p>

<h3>conclusion: "incorporation" of source code is a bad idea to begin with.</h3>

<p>now let's look at <strong>reason 2</strong> (better optimized code):
it possibly sometimes made sense to help the compiler do its job in the 70ies, when everything started.
however, it's 2013 now.
compilers do a great job optimizing, and they get better at it every day.</p>

<p>since GCC 4.5 was released in 2010, it ships with a feature called LTO
it builds object files together with metadata that allows it to strip off unneeded functions and variables, inline functions that are only called once or twice, etc at link time - pretty much anything the sqlite devs want to achieve, and probably even more than that.</p>

<h3>conclusion: pseudo-optimizing C code by stuffing everything into a big file is obsolete since LTO is widely available.</h3>

<p>LTO does a better job anyway - not that it matters much, as sqlite spends most time waiting for I/O.
every user who wants to make sqlite run faster, can simply add -flto to his CFLAGS.
there's no need to dictate him which optimization he wants to apply.
following this logic, they could as well just ship generated assembly code…</p>

<p>but hey - we have the choice !
<a href="https://www.sqlite.org/download.html">here</a>'s actually a tarball containing
the ORIGINAL, UN-ANAL-GAMATED SOURCE CODE...</p>

<p>... just that it's not a tarball.</p>

<p>it's a fscking <strong>ZIP</strong> file.
yes, you heard right.
they distribute their source as ZIP files, treating UNIX users as second-class
citizens.</p>

<p>additionally they say that you should not use it:</p>

<blockquote>
  <p>sqlite-src-3080002.zip (5.12 MiB)
A ZIP archive of the complete source tree for SQLite version 3.8.0.2 as extracted from the version control system.
The Makefile and configure script in this tarball are <strong>not supported</strong>.
<strong>Their use is not recommended</strong>.
The SQLite developers do not use them.
You <strong>should not use</strong> them either.
If you want a configure script and an automated build, use either the amalgamation tarball or TEA tarball instead of this one.
To build from this tarball, hand-edit one of the template Makefiles in the root directory of the tarball and build using your own customized Makefile.</p>
</blockquote>

<p>Note how the text talks about "this tarball" despite it being a ZIP file.</p>

<p>Fun. there's only a single TARball on the entire site, so that's what you naturally pick for your build system.
and that one contains the ANAL version.
Note that my distro's build system does not even support zip files, as i don't have a single package in my repo that's not building from a tarball.
should i change it and write special case code for one single package which doesn't play by the rules ?
i really don't think so.</p>

<p>funny fact: they even distribute <strong>LINUX BINARY downloads</strong> as .zip.
i wonder in which world they live in.</p>

<p>why do i care so much about build time ? it's just a minute after all.
because the distribution gets built over and over again. and it's not just me building it, but a lot of other people as well - so the cumulated time spent waiting for sqlite to finish building its 5 MB file gets bigger and bigger each day.
in the past i built sqlite more than 200 times, so my personal cumulated wasted time on it already exceeds the amount of time i needed to write this blog post.</p>

<p>so what i hope to see is sqlite</p>

<ul>
<li>using tarballs for all their sources (and eventually distribute an additional .zip for windows lusers)</li>
<li>using tarballs for their precompiled linux downloads</li>
<li>either getting rid of the anal version entirely, now that they learned about LTO, or offer the anal version as an additional download and do not discourage users from using the sane version.</li>
</ul>

<h3>Update:</h3>

<p>I just upgraded sqlite from 3071000 to 3080002</p>

<pre><code>2013.09.27 02:23:24 building sqlite (/src/build/build_sqlite.sh) -&gt; /src/logs/build_sqlite.log
2013.09.27 02:25:31 done.
</code></pre>

<p>it now takes more than 2 minutes.</p>

<h5>this blog post originally appeared on my currently defunct <a href="https://devsonacid.wordpress.com/2013/09/25/sqlites-anal-gamation/">wordpress blog</a></h5>
<p><a href="1/#comments">Post or read comments...</a></p></div>



</body>
</html>
