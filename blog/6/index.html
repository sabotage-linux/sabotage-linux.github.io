<html><head><title>Devs on Acid - Restoring accidentally deleted files on Linux</title>
<link rel="shortcut icon" href="/favicon.ico" type="image/png">
<link rel="stylesheet" href="/blog/main.css" type="text/css">
</head>

<body>

<div class="header">
<h1>Devs on Acid</h1>
<ul class="menu">
<li><a class=amenu href="/blog/">Home</a>
<li><a class=amenu href="/blog/about">About</a>
<li><a class=amenu href="/blog/feed.rss">RSS</a>
</ul>
</div>

<div class="article"><h2>Restoring accidentally deleted files on Linux</h2>

<div class="pub">02 May 2019 22:27 UTC</div>
<p>Doh. Through a tiny bug in a Makefile auto-generated by my build system
<a href="https://github.com/rofl0r/rcb2">rcb2</a>, I accidentally deleted the C source file
I've been working on for almost an hour, and which wasn't checked into git yet.</p>

<p>Fortunately, I know the basic steps to restore a file<code>*</code> in a filesystem-agnostic
way.</p>

<p>These are:</p>

<ul>
<li>open the raw blockdevice (e.g. <code>/dev/sda1/</code>) the file was on,</li>
<li>search for a string known to be (only) inside the deleted file,</li>
<li>from that position on, find the start and end offsets of the file,</li>
<li>restore it using these offsets with the <code>dd</code> utility to another blockdevice.</li>
</ul>

<p>First of all though, I sent a <code>SIGSTOP</code> signal to firefox, the most volatile
process on my desktop, to prevent it from writing any files onto my harddisk
while the restoration was in process, potentially overwriting the blocks
occupied by the deleted file.
I did this via <a href="https://github.com/sabotage-linux/sabotage/blob/802aeb7/KEEP/openbox-add_iconify_and_pause.patch">an extension</a>
I wrote for my Window Manager <a href="http://openbox.org/">openbox</a>, which adds a
menu item "Pause and iconify" to the popup menu on the titlebar of all windows.
I usually use this to prevent Firefox from consuming CPU and draining my
laptop's battery, while I'm traveling.
Other than that, there's almost nothing running on a typical <a href="http://github.com/sabotage-linux/sabotage/">sabotage linux</a>
box which could interfere via constant disk writes, unlike GNU/Linux systems
with systemd and a gazillion of background daemons installed.</p>

<p>Then I opened <code>/dev/mapper/crypt_home</code>, the blockdevice containing my <code>/home</code>
filesystem in my <a href="https://github.com/rofl0r/hexedit0r">favorite hexeditor</a>, went
on the ascii tab on the right side, and started a search for a string I knew was
only in that new C file, which was <code>&lt;openDOW/vec2f.h&gt;</code> since I used that file
in a hackish way via an include statement.</p>

<p>After hitting ENTER in <code>hexedit</code>'s search dialog, CPU usage went to 100%,
and it slowly crunched its way through the encrypted harddisk's blockdevice
mapper.
I left my computer to brew a coffee, and came back after about 5 minutes.
From the current offset displayed, I figured that the search was currently only
40GB into the blockdevice.
Many more GBs to go, since the file could be at the very end of the SSD.
After another break of about 10 mins, I was lucky enough and the string was
found at offset 0x13c6ffa0ab, at about 84 GB into the blockdevice.</p>

<p>Using pageup/pagedown in hexedit, the beginning and end offsets of the source
file were quickly found. They were 0x13C6FF1FFC and 0x13C6FFB472, respectively.</p>

<pre><code>dd if=/dev/mapper/crypt_home of=/dev/shm/dump bs=1 skip=$((0x13C6FF1FFC)) count=$((0x13C6FFB472 - 0x13C6FF1FFC))
</code></pre>

<p>did the rest to restore the file onto <code>/dev/shm</code>, the ramdrive.</p>

<p>Since my SSD is usually a lot faster than this, I decided to write a program
to speed up future searches. The plan is simple, one needs to read from the
filesys in large chunks, so the time spent in syscalls is neglible, and then
search over the memory chunks using an optimized algorithm that compares
word-at-a-time, just like musl's <code>memmem()</code> <a href="http://git.musl-libc.org/cgit/musl/tree/src/string/memmem.c">function does</a>.
Plus some more logic to find the searchterm even across chunk boundaries.
The result can be found <a href="https://github.com/rofl0r/hardcore-utils/blob/de5a4ca/fastfind.c">here</a>
in a small C program.</p>

<p>And indeed, it is a lot faster than <code>hexedit</code>.</p>

<pre><code># time ./fastfind /dev/mapper/crypt_home '&lt;openDOW/vec2f.h&gt;'
curr: 0x13498f0000
bingo: 0x13c6ffa0ab
^CCommand terminated by signal 2
real    1m 4.26s
user    0m 20.35s
sys     0m 19.38s
</code></pre>

<p>at 64 seconds total, it crunched through the blockdevice at a rate of 1.2GB/sec,
at least 10x faster than <code>hexedit</code>.</p>

<p>So for future undelete tasks, my <code>fastfind</code> utility will become the first stop,
to find an offset, which will then be followed by my good old friend <code>hexedit</code>
to find beginning and end position in the neighbourhood of that offset, and to
be finished off with <code>dd</code>.</p>

<p><code>*</code>: This approach works well for smaller files, whereas bigger ones are usually
spread over several non-adjacent blocks.</p>
</div>



</body>
</html>
