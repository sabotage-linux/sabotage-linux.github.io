<html><head><title>Devs on Acid - benchmarking python bytecode vs interpreter speed and bazaar vs git</title>
<link rel="shortcut icon" href="/favicon.ico" type="image/png">
<link rel="stylesheet" href="/blog/main.css" type="text/css">
</head>

<body>

<div class="header">
<h1>Devs on Acid</h1>
<ul class="menu">
<li><a class=amenu href="/blog/">Home</a>
<li><a class=amenu href="/blog/about">About</a>
<li><a class=amenu href="/blog/feed.rss">RSS</a>
</ul>
</div>

<div class="article"><h2>benchmarking python bytecode vs interpreter speed and bazaar vs git</h2>

<div class="pub">07 Apr 2019 00:39 UTC</div>
<p>A couple weeks ago,
after an upgrade of libffi, we experienced odd build errors of python only on
systems where python had previously been installed with an older libffi version:</p>

<pre><code>error: [Errno 2] No such file or directory: '/lib/libffi-3.0.13/include/ffi.h'
</code></pre>

<p>There was no reference to <code>libffi-3.0.13</code> anywhere in the python source, and it
turned out that it was contained in old python .pyc/.pyo bytecode files that
survived a rebuild due to a packaging bug, and apparently were queried as
authorative during the python build.</p>

<pre><code>/lib/python2.7/_sysconfigdata.pyc:/lib/libffi-3.0.13/include
/lib/python2.7/_sysconfigdata.pyo:/lib/libffi-3.0.13/include
</code></pre>

<p>The packaging bug was that we didn't pre-generate .pyc/.pyo files just after the
build of python, so they would become part of the package directory in
/opt/python, but instead they were created on first access directly in
/lib/python2.7, resulting in the following layout:</p>

<pre><code>~ $ la /lib/python2.7/ | grep sysconfigdata
lrwxrwxrwx    1 root     root            48 Mar  4 03:11 _sysconfigdata.py -&gt; ../../opt/python/lib/python2.7/_sysconfigdata.py
-rw-r--r--    1 root     root         19250 Mar  4 03:20 _sysconfigdata.pyc
-rw-r--r--    1 root     root         19214 Jun 30  2018 _sysconfigdata.pyo
</code></pre>

<p>So on a rebuild of python, only the symlinks pointing to /opt/python were
removed, while the generated-on-first-use .pyc/.pyo files survived.</p>

<p>Annoyed by this occurence I started researching how generation of these bytecode
file could be suppressed, and it turned out that it can be controlled using a
<code>sys.dont_write_bytecode</code> variable, which in turn is set from the python C code.
Here's a <a href="https://gist.github.com/rofl0r/45d5c22a28ba346547ab2d0bad93bd7b">patch</a> doing that.</p>

<p>However, before turning off a feature that can potentially be a huge performance
boost, a responsible distro maintainer needs to do a proper benchmarking study
so he can make an educated decision.</p>

<p>So I developed a benchmark, that runs a couple of tasks using the <code>bazaar</code>
VCS system, which is written in python and uses a large amount of small files,
so the startup overhead should be significant. The task is executed 50 times, so
small differences in the host's CPU load due to other tasks should be evened
out.</p>

<p>The task is to generate a new bazaar repo, check 2 files and a directory into
bazaar in 3 commits, and print a log at the end.</p>

<script src="https://gist.github.com/rofl0r/0e48b188c0278f6f4dcc5e20b36b5105.js"></script>

<p>With bytecode generation disabled, the benchmark produced the following results:</p>

<pre><code>real    3m 15.75s
user    2m 15.40s
sys     0m 4.12s
</code></pre>

<p>With pregenerated bytecode, the following results were measured:</p>

<pre><code>real    1m 24.25s
user    0m 20.26s
sys     0m 2.55s
</code></pre>

<p>We can see, that in the case of a fairly big application like bazaar with
hundreds of python files, the precompilation does indeed make a quite noticable
difference. It is more than twice as fast.</p>

<p>What's also becoming apparent is that bazaar is slow as hell.
For the lulz, I replaced the bzr command in the above benchmark with git and
exported <code>PAGER=cat</code> so <code>git log</code> wouldn't interrupt the benchmark.
As expected, git is orders of magnitude faster:</p>

<pre><code>real    0m 0.48s
user    0m 0.02s
sys     0m 0.05s
</code></pre>

<p>Out of curiosity, I fiddled some more with python and added a <a href="https://gist.github.com/rofl0r/acd9da221c3c3f07213e87128ed37288">patch</a> that
builds python so its optimization switch <code>-O</code> is always active, and rebuilt both
python and bazaar to produce only .pyo files instead of .pyc.
Here are the results:</p>

<pre><code>real    1m 23.88s
user    0m 20.18s
sys     0m 2.54s
</code></pre>

<p>We can see that the optimization flag is next to useless. The difference is so
small it's almost not measurable.</p>

<p>Now this benchmark was tailored to measure startup compilation cost for a big
project, what about a mostly CPU-bound task using only a few python modules?</p>

<p>I modified a password bruteforcer to exit after a couple thousand rounds for
this purpose, and ran it 30x each without bytecode, with .pyc and .pyo each.</p>

<script src="https://gist.github.com/rofl0r/20ad5740cf741ce85d252b944e0b5ce9.js"></script>

<p>Here are the results:</p>

<p>No bytecode:</p>

<pre><code>real    3m 50.42s
user    3m 50.25s
sys     0m 0.03s
</code></pre>

<p>.pyc bytecode:</p>

<pre><code>real    3m 48.68s
user    3m 48.60s
sys     0m 0.01s
</code></pre>

<p>.pyo bytecode:</p>

<pre><code>real    3m 49.14s
user    3m 49.06s
sys     0m 0.01s
</code></pre>

<p>As expected, there's almost no difference between the 3. Funnily enough, the
optimized bytecode is even slower than the non-optimized bytecode in this case.</p>

<p>From my reading of this <a href="https://stackoverflow.com/questions/33781414/disable-python-basic-optimization-o">stackoverflow question</a>
it appears to me as if the .pyo bytecode differs from regular bytecode only in
that it lacks instructions for the omitted assert() calls, and eventually debug
facilities.</p>

<p>Which brings us back to the original problem: In order to have the .pyc files
contained in the package directory, they need to be generated manually during
the build, because apparently they're not installed as part of <code>make install</code>.
This can be achieved by calling</p>

<pre><code>./python -E Lib/compileall.py "$dest"/lib/python2.7
</code></pre>

<p>after make install finished.
With that achieved, i compared the size of the previous /opt/python directory
without .pyc files with the new one.</p>

<p>It's 22.2 MB vs 31.1MB, so the .pyc files add roughly 9MB and make the package
almost 50% bigger.</p>

<p>Now it happens that some python packages, build scripts and the like call python
with the optimization flag <code>-O</code>. this causes our previous problem to re-appear,
now we will have stray .pyo files in /lib/python2.7.</p>

<p>So we need to pregenerate not only .pyc, but also .pyo for all python modules.
This will add another 9MB to the python package directory.</p>

<p>OR... we could simply <strong>turn off</strong> the ability to activate the optimised mode,
which as we saw, is 99.99% useless.
This seems to be the most reasonable thing to do, and therefore this is
precisely what I <a href="https://github.com/sabotage-linux/sabotage/commit/145a77a0ced2a628b52d700071fae7e87f830010">now implemented in sabotage linux</a>.</p>
</div>



</body>
</html>
